#include"pch.h"
#include"EnemyManager.h"
#include"Scene/GameObjects/PlayScene/Character/Player/Player.h"
#include"Enemy_01.h"
#include"Enemy_02.h"
#include"EnemyCustom_00.h"
using namespace DirectX;

const int ENEMY_00_COUNT(0);	//敵＿０１の数
const int ENEMY_01_COUNT(2);	//敵＿０２の数
const int ENEMY_02_COUNT(2);	//敵＿０３の数
							
EnemyManager::EnemyManager() :
	m_killCount(),
	m_generationTime(),
	m_pBulletManager(nullptr),
	m_pPlayer(nullptr)
{
	//種類によって生成
	for (int i = 0; i < ENEMY_00_COUNT; i++)
	{
		//敵のインスタンスを生成
		std::unique_ptr<Enemy> enemy = std::make_unique<EnemyCustom_00>(100,100000,3);
		m_enemyList.push_back(std::move(enemy));
	}
	for (int i = 0; i < ENEMY_01_COUNT; i++)
	{
		//敵のインスタンスを生成
		std::unique_ptr<Enemy> enemy = std::make_unique<Enemy_01>();
		m_enemyList.push_back(std::move(enemy));
	}
	for (int i = 0; i < ENEMY_02_COUNT; i++)
	{
		//敵のインスタンスを生成
		std::unique_ptr<Enemy> enemy = std::make_unique<Enemy_02>();
		m_enemyList.push_back(std::move(enemy));
	}
}

EnemyManager::~EnemyManager()
{

}

//ゲームの初期化を行う関数
void EnemyManager::Intialize(
	BulletManager* bulletManager,
	Player* player,
	ObjectsManager* objectsManager,
	AirshipManager* airhhipManager,
	WindmillManager* windmillManager,
	Floor* floor,
	SandstormManager* sandstormManager,
	FloorManager_01* floorManager_01,
	BigBrickWallManager* bigBrickWallManager
)
{
	//球の管理者のポインタを取得
	m_pBulletManager = bulletManager;

	//プレイヤーのポインタを取得
	m_pPlayer = player;

	//オブジェクトの管理者のポインタを取得
	m_pObjectsManager = objectsManager;

	//飛行船の管理者のポインタを取得
	m_pAirshipManager = airhhipManager;

	//風車の管理者のポインタを取得
	m_pWindmillManager = windmillManager;

	//床のポインタを取得
	m_pFloor = floor;

	//砂嵐の管理者のポインタを取得
	m_pSandstormManager = sandstormManager;

	//すべての球を未使用状態にする
	for (int i = 0; i < m_enemyList.size(); i++)
	{
		//ランダムな位置
		m_enemyList[i]->SetpositionRandam(-150, 150);

		//初期化
		m_enemyList[i]->Initialize(
			m_pBulletManager, 
			this, 
			m_pObjectsManager,
			m_pPlayer,
			m_pAirshipManager, 
			m_pWindmillManager,
			m_pFloor,
			m_pSandstormManager,
			floorManager_01,
			bigBrickWallManager
		);
	}
}

//ゲームの更新を行う関数
void EnemyManager::Update(const float& elapsedTime)
{
	//自動生成の関数
	AutoGenerated();

	//球の更新
	for (int i = 0; i < m_enemyList.size(); i++)
	{
		if (!m_enemyList[i]->GetSurvival())
			continue;

		//デスポーン距離
		if (Draw::GetInstance()->DespawnDistance(m_enemyList[i]->GetPosition(), 300.0f))
		{
			m_enemyList[i]->SetSurvival(false);
			continue;
		}

		//敵の更新
		m_enemyList[i]->Update(elapsedTime);

	}
	//自動生成の時間をたす
	m_generationTime += elapsedTime;
}

//ゲームの更新処理を行う関数
void EnemyManager::Render()
{
	//球の描画
	for (auto& enemyList : m_enemyList)
	{
		//敵が生きているか
		if (!enemyList->GetSurvival())
			continue;
		//視界に入っているか
		if (Draw::GetInstance()->VisibilityRange(enemyList->GetPosition()))
			continue;

		//敵を描画
		enemyList->Render();

	}
}

void EnemyManager::RenderShadowTex()
{	//球の描画
	for (auto& enemyList : m_enemyList)
	{
		//敵が生きているか
		if (!enemyList->GetSurvival())
			continue;
		//視界に入っているか
		if (Draw::GetInstance()->VisibilityRange(enemyList->GetPosition()))
			continue;

		//敵を描画
		enemyList->RenderShadowTex();

	}

}

//ゲームの終了処理を行う関数。解放処理が必要な場合　（Release関数などを呼び出す）は、この関数内でしょるする
void EnemyManager::Finalize()
{
	//球の描画
	for (auto& enemyList : m_enemyList)
	{
		enemyList.reset();
	}
}

//敵を自動生成する
void EnemyManager::AutoGenerated()
{
	//１秒ごとに敵を生成
	if (m_generationTime >= 10)
	{	
		//発射可能な球を探す
		for (auto& enemyList : m_enemyList)
		{
			//生きているなら次へ
			if (enemyList->GetSurvival())	
				continue;

			//使用されてないなら初期化
			enemyList->SetpositionRandam(-150, 150);
			enemyList->Reset();
			
			//現在の状態を初期化（リセットをしてスピードなどが０になっているから）
			enemyList->GetIState()->Initialize();

			//生成時間を初期化
			m_generationTime = 0;

			//処理を中断する
			break;
		}
	}

}

void EnemyManager::CheckHitCharacter(Player* player)
{	
	//プレイヤーとの当たり判定
	for (int i = 0; i < m_enemyList.size(); i++)
	{
		//敵が生きているか
		if (!m_enemyList[i]->GetSurvival())		continue;

		//大まかなプレイヤーと大まかな敵の当たり判定
		if (!m_enemyList[i]->GetCollider()->CheckHitSphere(player->GetCollider()))
			continue;

		for (auto& playerParts : player->GetParts())
		{
			//プレイヤーのパーツと大まかな敵の当たり判定
			if (!playerParts->CollisionEnemy(m_enemyList[i].get()))
				continue;

			//そこまで細かくとらなくてもよいので割愛
			//プレイヤーのパーツと敵のパーツの当たり判定
			for (auto& enemyParts : m_enemyList[i]->GetParts())
			{
				if (!playerParts->Collision(enemyParts.get()))
					continue;

				m_enemyList[i]->Damage(Player::PLAYER_OFFENSIVE_POWER);
				player->Damage(m_enemyList[i]->GetOffensivePower());
			}
		}
	}
}
